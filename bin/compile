#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir>

#This script performs the buildpack transformation. BUILD_DIR will be the location of the app
#and CACHE_DIR will be a location the buildpack can use to cache build artifacts between builds.

#All output received on stdout from this script will be displayed to the user (for interactive git-push builds) and stored with the build.

#The application in BUILD_DIR along with all changes made by the compile script will be packaged into a slug.

#ENV_DIR is a directory that contains a file for each of the applicationâ€™s configuration variables.
#Config vars are made available as environment variables during execution of commands specified in the Procfile, as well as when running one-off processes.



# Fail fast
#Exit immediately if a command exits with a non-zero status.
set -e

# Debug
#Print a trace of simple commands
# set -x

# Clean up leaking environment
unset GIT_DIR

# Parameters
BUILD_DIR=$1
CACHE_DIR="${2}/${STACK}"
TARGET_VENDOR_DIR=".heroku/vendor"
PROFILE_PATH="$BUILD_DIR/.profile.d/geo.sh"
APP_VENDOR="/app/$TARGET_VENDOR_DIR"
S3_BUCKET=${HEROKU_GEO_BUILDBACK_S3_BUCKET:-"cyberdelia-geo-buildpack"}

# Setup profile file
mkdir -p $(dirname $PROFILE_PATH)
mkdir -p "$CACHE_DIR"
mkdir -p $BUILD_DIR/$TARGET_VENDOR_DIR

# Functions
function indent() {
  c='s/^/       /'
  case $(uname) in
    Darwin) sed -l "$c";;
    *)      sed -u "$c";;
  esac
}

function manifest_version() {
  curl "http://${S3_BUCKET}.s3.amazonaws.com/${STACK}/manifest.${1}" -s -o - | head -n 1
}

function download_package() {
  name="$1"
  version="$2"
  location="$3"

  mkdir -p $location
  package="https://${S3_BUCKET}.s3.amazonaws.com/${STACK}/$name-$version.tgz"
  curl $package -s -o - | tar xzf - -C $location
}

function set_env (){
  echo "export $1=$2" >> $PROFILE_PATH
}

function set_default_env (){
  echo "export $1=\${$1:-$2}" >> $PROFILE_PATH
}

#Display information for each package
function display_info_for_package (){
  version=$(manifest_version "${1}")
  echo "Using ${1} version: $version" | indent
}

#Moved old fetch and vendor code into function, to be called for each library
function fetch_and_vendor (){
  version=$(manifest_version "${1}")
  vendored="vendor/${1}/$version"
  #If the file doesn't exist
  if [ ! -d $CACHE_DIR/$vendored ]; then
    echo "-----> Fetching and vendoring ${1}"
    rm -rf "$CACHE_DIR/vendor/${1}"
    download_package "${1}" "${version}" "${CACHE_DIR}/${vendored}"
  fi
 
  # Copy artifacts out of cache if exists.
  cp -r $CACHE_DIR/$vendored/* $BUILD_DIR/$TARGET_VENDOR_DIR &> /dev/null || true
}

display_info_for_package "geos"
display_info_for_package "gdal"
display_info_for_package "proj"

fetch_and_vendor "geos"
fetch_and_vendor "gdal"
fetch_and_vendor "proj"

# Setup environment variables
set_env GEOS_LIBRARY_PATH "$APP_VENDOR/lib"
set_env GDAL_LIBRARY_PATH "$APP_VENDOR/lib"
set_env PROJ4_LIBRARY_PATH "$APP_VENDOR/lib"
set_env GDAL_DATA "$APP_VENDOR/share/gdal"

# Bundle workaround
mkdir -p $BUILD_DIR/.bundle
if [ -f $CACHE_DIR/.bundle/config ]; then
  rm $CACHE_DIR/.bundle/config
fi
echo "---
BUNDLE_BUILD__RGEO: "--with-geos-dir=$BUILD_DIR/$TARGET_VENDOR_DIR --with-geos-lib=$BUILD_DIR/$TARGET_VENDOR_DIR/lib --with-proj-dir=$BUILD_DIR/$TARGET_VENDOR_DIR --with-proj-lib=$BUILD_DIR/$TARGET_VENDOR_DIR/lib"
BUNDLE_FROZEN: '1'
BUNDLE_PATH: vendor/bundle
BUNDLE_BIN: vendor/bundle/bin
BUNDLE_WITHOUT: development:test
BUNDLE_DISABLE_SHARED_GEMS: '1'
" > $BUILD_DIR/.bundle/config

set_default_env LIBRARY_PATH "$APP_VENDOR/lib"
set_default_env LD_LIBRARY_PATH "$APP_VENDOR/lib"
set_default_env CPATH "$APP_VENDOR/include"

echo "-----> Vendoring geo libraries done"
